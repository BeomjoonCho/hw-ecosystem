# 백엔드 및 데이터베이스 연동 개발 계획

## 개요

현재 프론트엔드 위주로 개발된 기술 파트너 대시보드를 실제 백엔드와 데이터베이스와 연동하여 완전한 풀스택 애플리케이션으로 전환하는 개발 계획서입니다.

## 목차

1. [현재 상태 분석](#현재-상태-분석)
2. [아키텍처 설계](#아키텍처-설계)
3. [데이터베이스 설계](#데이터베이스-설계)
4. [API 설계](#api-설계)
5. [인증 및 인가](#인증-및-인가)
6. [단계별 개발 계획](#단계별-개발-계획)
7. [기술 스택 선택](#기술-스택-선택)
8. [보안 고려사항](#보안-고려사항)
9. [성능 최적화](#성능-최적화)
10. [배포 전략](#배포-전략)

---

## 현재 상태 분석

### 현재 구현된 기능

1. **프론트엔드 기능**
   - 파트너 목록 조회 (정적 데이터)
   - 파트너 상세 정보 조회
   - 키워드 기반 필터링
   - 기술 점수/시장 점수 표시
   - 파트너 기술 제안 모달
   - 시장 동향/컨퍼런스 동향 표시

2. **데이터 구조**
   - `Partner` 인터페이스 정의
   - `TechnologyIntelligence` 인터페이스 정의
   - 샘플 데이터 하드코딩

3. **제한사항**
   - 모든 데이터가 클라이언트 사이드에 하드코딩
   - 데이터 영속성 없음
   - 사용자 인증/인가 없음
   - 실시간 업데이트 불가
   - 검색 기능 없음

---

## 아키텍처 설계

### 전체 아키텍처

```
┌─────────────────────────────────────────────────────────┐
│                    Client (Next.js)                      │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │   Pages      │  │  Components  │  │   Hooks      │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└──────────────────────┬──────────────────────────────────┘
                       │ HTTP/REST API
┌──────────────────────┴──────────────────────────────────┐
│              Next.js API Routes / Backend API            │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │   Auth       │  │  Partners    │  │  Analytics   │  │
│  │   Service    │  │  Service     │  │  Service     │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└──────────────────────┬──────────────────────────────────┘
                       │ ORM/Query
┌──────────────────────┴──────────────────────────────────┐
│                    Database Layer                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │  PostgreSQL  │  │   Redis      │  │   File       │  │
│  │  (Primary)   │  │  (Cache)     │  │   Storage    │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└───────────────────────────────────────────────────────────┘
```

### 아키텍처 패턴

1. **3-Tier Architecture**
   - Presentation Layer (Next.js Frontend)
   - Application Layer (API Routes / Backend Service)
   - Data Layer (PostgreSQL + Redis)

2. **API 설계 원칙**
   - RESTful API 설계
   - GraphQL 고려 (복잡한 쿼리 시)
   - API 버전 관리 (`/api/v1/`)

3. **데이터 흐름**
   - Client → API Route → Service Layer → Database
   - Caching 전략: Redis 활용
   - 실시간 업데이트: WebSocket 또는 Server-Sent Events

---

## 데이터베이스 설계

### ERD (Entity Relationship Diagram)

```
┌─────────────────┐         ┌──────────────────┐
│     Users       │         │    Partners      │
├─────────────────┤         ├──────────────────┤
│ id (PK)         │         │ id (PK)          │
│ email           │         │ name             │
│ password_hash   │         │ description      │
│ name            │         │ website          │
│ role            │         │ founded_year     │
│ created_at      │         │ location         │
│ updated_at      │         │ ceo              │
└─────────────────┘         │ employee_count   │
                            │ status           │
┌─────────────────┐         │ business_years   │
│  Technologies   │         │ patents          │
├─────────────────┤         │ core_technology  │
│ id (PK)         │◄────────┤ project_count    │
│ name            │         │ total_project_cnt│
│ category        │         │ tech_score       │
│ created_at      │         │ market_score     │
└─────────────────┘         │ created_at      │
         │                   │ updated_at      │
         │                   └──────────────────┘
         │                            │
         │                            │
┌─────────────────┐         ┌──────────────────┐
│ Partner_Tech    │         │   Keywords        │
├─────────────────┤         ├──────────────────┤
│ partner_id (FK) │         │ id (PK)          │
│ tech_id (FK)    │         │ name             │
│ created_at      │         │ category         │
└─────────────────┘         └──────────────────┘
         │                            │
         │                            │
┌─────────────────┐         ┌──────────────────┐
│ Partner_Keyword │         │   Projects       │
├─────────────────┤         ├──────────────────┤
│ partner_id (FK) │         │ id (PK)          │
│ keyword_id (FK) │         │ partner_id (FK)   │
│ created_at      │         │ company          │
└─────────────────┘         │ title            │
                            │ period           │
┌─────────────────┐         │ status           │
│  Proposals      │         │ created_at       │
├─────────────────┤         └──────────────────┘
│ id (PK)         │
│ user_id (FK)     │         ┌──────────────────┐
│ company_name    │         │  Tech_Scores      │
│ website         │         ├──────────────────┤
│ ceo             │         │ id (PK)          │
│ status          │         │ partner_id (FK)   │
│ process_step    │         │ category         │
│ proposal_data   │         │ score            │
│ created_at      │         │ evaluated_at     │
│ updated_at      │         │ evaluator_id (FK) │
└─────────────────┘         └──────────────────┘

┌─────────────────┐         ┌──────────────────┐
│ Market_Scores   │         │  News_Articles   │
├─────────────────┤         ├──────────────────┤
│ id (PK)         │         │ id (PK)          │
│ partner_id (FK) │         │ title            │
│ category        │         │ url              │
│ score           │         │ date             │
│ evaluated_at    │         │ source           │
│ evaluator_id(FK)│         │ created_at      │
└─────────────────┘         └──────────────────┘
```

### 주요 테이블 상세 설계

#### 1. partners 테이블

```sql
CREATE TABLE partners (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL UNIQUE,
    description TEXT,
    website VARCHAR(500),
    founded_year INTEGER,
    location VARCHAR(255),
    ceo VARCHAR(255),
    employee_count INTEGER,
    status VARCHAR(50), -- '상장', '비상장'
    business_years DECIMAL(5,2),
    patents INTEGER DEFAULT 0,
    core_technology TEXT,
    project_count INTEGER DEFAULT 0,
    total_project_count INTEGER DEFAULT 0,
    technology_score DECIMAL(3,1) DEFAULT 0.0,
    market_score DECIMAL(3,1) DEFAULT 0.0,
    similar_companies TEXT[], -- Array of company names
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by UUID REFERENCES users(id),
    updated_by UUID REFERENCES users(id)
);

CREATE INDEX idx_partners_name ON partners(name);
CREATE INDEX idx_partners_tech_score ON partners(technology_score DESC);
CREATE INDEX idx_partners_market_score ON partners(market_score DESC);
CREATE INDEX idx_partners_created_at ON partners(created_at DESC);
```

#### 2. technologies 테이블

```sql
CREATE TABLE technologies (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL UNIQUE,
    category VARCHAR(100), -- 'LLM', 'RAG', 'IoT', etc.
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_technologies_name ON technologies(name);
CREATE INDEX idx_technologies_category ON technologies(category);
```

#### 3. partner_technologies 테이블 (Many-to-Many)

```sql
CREATE TABLE partner_technologies (
    partner_id UUID REFERENCES partners(id) ON DELETE CASCADE,
    technology_id UUID REFERENCES technologies(id) ON DELETE CASCADE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (partner_id, technology_id)
);

CREATE INDEX idx_partner_tech_partner ON partner_technologies(partner_id);
CREATE INDEX idx_partner_tech_tech ON partner_technologies(technology_id);
```

#### 4. keywords 테이블

```sql
CREATE TABLE keywords (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL UNIQUE,
    category VARCHAR(100), -- '기술', '산업', '기능'
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_keywords_name ON keywords(name);
```

#### 5. partner_keywords 테이블

```sql
CREATE TABLE partner_keywords (
    partner_id UUID REFERENCES partners(id) ON DELETE CASCADE,
    keyword_id UUID REFERENCES keywords(id) ON DELETE CASCADE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (partner_id, keyword_id)
);
```

#### 6. projects 테이블

```sql
CREATE TABLE projects (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    partner_id UUID REFERENCES partners(id) ON DELETE CASCADE,
    company VARCHAR(255) NOT NULL, -- 한화 계열사명
    title VARCHAR(500) NOT NULL,
    period VARCHAR(100), -- '2024.01 - 2024.12'
    status VARCHAR(50), -- '진행중', '완료', '계획중'
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_projects_partner ON projects(partner_id);
CREATE INDEX idx_projects_company ON projects(company);
CREATE INDEX idx_projects_status ON projects(status);
```

#### 7. tech_scores 테이블 (상세 기술 점수)

```sql
CREATE TABLE tech_scores (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    partner_id UUID REFERENCES partners(id) ON DELETE CASCADE,
    category VARCHAR(50) NOT NULL, -- 'A1', 'A2', 'A3', 'B1', 'B2', 'B3'
    score DECIMAL(3,1) NOT NULL CHECK (score >= 0 AND score <= 10),
    evaluated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    evaluator_id UUID REFERENCES users(id),
    notes TEXT,
    UNIQUE(partner_id, category)
);

CREATE INDEX idx_tech_scores_partner ON tech_scores(partner_id);
CREATE INDEX idx_tech_scores_category ON tech_scores(category);
```

#### 8. market_scores 테이블 (상세 시장 점수)

```sql
CREATE TABLE market_scores (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    partner_id UUID REFERENCES partners(id) ON DELETE CASCADE,
    category VARCHAR(50) NOT NULL, -- 'C1', 'C2', 'C3', 'D1', 'D2', 'D3'
    score DECIMAL(3,1) NOT NULL CHECK (score >= 0 AND score <= 10),
    evaluated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    evaluator_id UUID REFERENCES users(id),
    notes TEXT,
    UNIQUE(partner_id, category)
);

CREATE INDEX idx_market_scores_partner ON market_scores(partner_id);
```

#### 9. proposals 테이블 (파트너 기술 제안)

```sql
CREATE TABLE proposals (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    company_name VARCHAR(255) NOT NULL,
    website VARCHAR(500),
    ceo VARCHAR(255),
    founded_year INTEGER,
    location VARCHAR(255),
    main_technologies TEXT,
    core_technology TEXT,
    proposal_background TEXT,
    technical_advantage TEXT,
    applicable_fields TEXT,
    expected_effects TEXT,
    references TEXT,
    additional_comments TEXT,
    status VARCHAR(50) DEFAULT 'submitted', -- 'submitted', 'reviewing', 'approved', 'rejected'
    process_step VARCHAR(50) DEFAULT 'input', -- 'input', 'review', 'purchase'
    reviewed_by UUID REFERENCES users(id),
    reviewed_at TIMESTAMP,
    review_notes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_proposals_user ON proposals(user_id);
CREATE INDEX idx_proposals_status ON proposals(status);
CREATE INDEX idx_proposals_process_step ON proposals(process_step);
```

#### 10. users 테이블

```sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    name VARCHAR(255) NOT NULL,
    role VARCHAR(50) DEFAULT 'user', -- 'admin', 'evaluator', 'user'
    department VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_login TIMESTAMP
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_role ON users(role);
```

#### 11. news_articles 테이블 (시장 동향)

```sql
CREATE TABLE news_articles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title VARCHAR(500) NOT NULL,
    url VARCHAR(1000) NOT NULL UNIQUE,
    date DATE,
    source VARCHAR(255),
    category VARCHAR(50) DEFAULT 'market', -- 'market', 'conference'
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_news_category ON news_articles(category);
CREATE INDEX idx_news_date ON news_articles(date DESC);
```

#### 12. audit_logs 테이블 (감사 로그)

```sql
CREATE TABLE audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    action VARCHAR(100) NOT NULL, -- 'CREATE', 'UPDATE', 'DELETE', 'VIEW'
    entity_type VARCHAR(50) NOT NULL, -- 'partner', 'proposal', 'score'
    entity_id UUID NOT NULL,
    changes JSONB, -- 변경 전/후 데이터
    ip_address VARCHAR(45),
    user_agent TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_audit_user ON audit_logs(user_id);
CREATE INDEX idx_audit_entity ON audit_logs(entity_type, entity_id);
CREATE INDEX idx_audit_created ON audit_logs(created_at DESC);
```

### 데이터베이스 마이그레이션 전략

1. **마이그레이션 도구**: Prisma Migrate 또는 TypeORM Migrations
2. **버전 관리**: Git과 연동하여 마이그레이션 파일 관리
3. **환경별 관리**: 개발/스테이징/프로덕션 환경별 스키마 관리

---

## API 설계

### API 엔드포인트 구조

#### Base URL
- Development: `http://localhost:3000/api/v1`
- Production: `https://api.example.com/v1`

### 인증 관련 API

```
POST   /api/v1/auth/register          # 회원가입
POST   /api/v1/auth/login             # 로그인
POST   /api/v1/auth/logout             # 로그아웃
POST   /api/v1/auth/refresh           # 토큰 갱신
GET    /api/v1/auth/me                # 현재 사용자 정보
PUT    /api/v1/auth/profile           # 프로필 수정
POST   /api/v1/auth/password/change   # 비밀번호 변경
```

### 파트너 관련 API

```
GET    /api/v1/partners               # 파트너 목록 조회 (페이징, 필터링, 정렬)
GET    /api/v1/partners/:id           # 파트너 상세 조회
POST   /api/v1/partners               # 파트너 생성 (관리자)
PUT    /api/v1/partners/:id           # 파트너 수정 (관리자)
DELETE /api/v1/partners/:id           # 파트너 삭제 (관리자)
GET    /api/v1/partners/search        # 파트너 검색
GET    /api/v1/partners/keyword/:keyword  # 키워드로 필터링
```

### 기술/키워드 관련 API

```
GET    /api/v1/technologies           # 기술 목록
GET    /api/v1/keywords               # 키워드 목록
GET    /api/v1/keywords/popular       # 인기 키워드
```

### 점수 관련 API

```
GET    /api/v1/partners/:id/scores/technology    # 기술 점수 상세
GET    /api/v1/partners/:id/scores/market        # 시장 점수 상세
POST   /api/v1/partners/:id/scores/technology    # 기술 점수 평가 (평가자)
POST   /api/v1/partners/:id/scores/market        # 시장 점수 평가 (평가자)
PUT    /api/v1/partners/:id/scores/technology/:category  # 특정 항목 점수 수정
PUT    /api/v1/partners/:id/scores/market/:category     # 특정 항목 점수 수정
```

### 프로젝트 관련 API

```
GET    /api/v1/partners/:id/projects  # 파트너의 수행 프로젝트 목록
POST   /api/v1/partners/:id/projects  # 프로젝트 추가
PUT    /api/v1/projects/:id            # 프로젝트 수정
DELETE /api/v1/projects/:id            # 프로젝트 삭제
```

### 제안 관련 API

```
GET    /api/v1/proposals              # 제안 목록 (본인 것만 또는 관리자 전체)
GET    /api/v1/proposals/:id           # 제안 상세
POST   /api/v1/proposals              # 제안 제출
PUT    /api/v1/proposals/:id           # 제안 수정 (본인 것만)
PUT    /api/v1/proposals/:id/status    # 제안 상태 변경 (관리자)
PUT    /api/v1/proposals/:id/process   # 프로세스 단계 변경 (관리자)
DELETE /api/v1/proposals/:id          # 제안 삭제
```

### 뉴스/동향 관련 API

```
GET    /api/v1/news                   # 뉴스 목록 (시장 동향)
GET    /api/v1/news/:id                # 뉴스 상세
POST   /api/v1/news                    # 뉴스 추가 (관리자)
PUT    /api/v1/news/:id                # 뉴스 수정 (관리자)
DELETE /api/v1/news/:id                # 뉴스 삭제 (관리자)
GET    /api/v1/conferences             # 컨퍼런스 목록
```

### 통계/분석 API

```
GET    /api/v1/analytics/partners/stats        # 파트너 통계
GET    /api/v1/analytics/scores/trends         # 점수 트렌드
GET    /api/v1/analytics/keywords/trends       # 키워드 트렌드
GET    /api/v1/analytics/proposals/stats       # 제안 통계
```

### API 응답 형식

#### 성공 응답
```json
{
  "success": true,
  "data": {
    // 응답 데이터
  },
  "meta": {
    "page": 1,
    "limit": 20,
    "total": 100,
    "totalPages": 5
  }
}
```

#### 에러 응답
```json
{
  "success": false,
  "error": {
    "code": "PARTNER_NOT_FOUND",
    "message": "파트너를 찾을 수 없습니다.",
    "details": {}
  }
}
```

### API 버전 관리

- URL 기반 버전 관리: `/api/v1/`, `/api/v2/`
- 헤더 기반 버전 관리도 고려 가능

---

## 인증 및 인가

### 인증 방식

1. **JWT (JSON Web Token) 기반 인증**
   - Access Token: 짧은 수명 (15분 ~ 1시간)
   - Refresh Token: 긴 수명 (7일 ~ 30일)
   - HTTP-only Cookie에 저장

2. **세션 기반 인증 (대안)**
   - Redis에 세션 저장
   - 더 안전하지만 확장성 제약

### 인가 (권한 관리)

#### 역할 기반 접근 제어 (RBAC)

```
Role: admin
- 모든 파트너 CRUD
- 모든 제안 관리
- 점수 평가 및 수정
- 사용자 관리
- 시스템 설정

Role: evaluator
- 파트너 조회
- 점수 평가 및 수정
- 제안 검토 및 상태 변경

Role: user
- 파트너 조회
- 제안 제출
- 본인 제안 수정/삭제
```

### 보안 고려사항

1. **비밀번호 암호화**: bcrypt (salt rounds: 12)
2. **SQL Injection 방지**: Parameterized Queries
3. **XSS 방지**: 입력 데이터 검증 및 이스케이프
4. **CSRF 방지**: CSRF Token 사용
5. **Rate Limiting**: API 요청 제한
6. **HTTPS**: 프로덕션 환경 필수

---

## 단계별 개발 계획

### Phase 1: 기반 구축 (2주)

#### 1.1 데이터베이스 설정
- [ ] PostgreSQL 설치 및 설정
- [ ] 데이터베이스 스키마 설계 완료
- [ ] 마이그레이션 도구 설정 (Prisma/TypeORM)
- [ ] 초기 마이그레이션 파일 작성
- [ ] 개발 환경 DB 생성 및 연결 테스트

#### 1.2 ORM 설정
- [ ] Prisma 또는 TypeORM 설치 및 설정
- [ ] 모델 정의 (Entity 생성)
- [ ] 관계 설정 (Relations)
- [ ] 쿼리 빌더 테스트

#### 1.3 인증 시스템 기반
- [ ] JWT 라이브러리 설정
- [ ] 사용자 모델 생성
- [ ] 회원가입/로그인 API 기본 구조
- [ ] 비밀번호 해싱 구현

### Phase 2: 파트너 데이터 연동 (3주)

#### 2.1 파트너 CRUD API
- [ ] 파트너 목록 조회 API (페이징, 필터링)
- [ ] 파트너 상세 조회 API
- [ ] 파트너 생성 API (관리자)
- [ ] 파트너 수정 API (관리자)
- [ ] 파트너 삭제 API (관리자)

#### 2.2 기술/키워드 연동
- [ ] 기술 목록 API
- [ ] 키워드 목록 API
- [ ] 파트너-기술 관계 관리
- [ ] 파트너-키워드 관계 관리
- [ ] 키워드 기반 필터링 API

#### 2.3 프론트엔드 연동
- [ ] API 클라이언트 설정 (axios/fetch)
- [ ] React Query 또는 SWR 설정
- [ ] 파트너 목록 페이지 API 연동
- [ ] 파트너 상세 페이지 API 연동
- [ ] 키워드 필터링 기능 연동

#### 2.4 데이터 마이그레이션
- [ ] 기존 샘플 데이터를 DB로 이관
- [ ] 데이터 검증 스크립트 작성

### Phase 3: 점수 평가 시스템 (2주)

#### 3.1 점수 데이터 모델
- [ ] 기술 점수 테이블 설계
- [ ] 시장 점수 테이블 설계
- [ ] 점수 계산 로직 구현 (평균 계산)

#### 3.2 점수 평가 API
- [ ] 기술 점수 평가 API
- [ ] 시장 점수 평가 API
- [ ] 점수 수정 API
- [ ] 점수 이력 관리

#### 3.3 프론트엔드 연동
- [ ] 점수 평가 UI 연동
- [ ] 점수 표시 연동
- [ ] 점수 수정 기능

### Phase 4: 프로젝트 관리 (1주)

#### 4.1 프로젝트 API
- [ ] 프로젝트 목록 조회 API
- [ ] 프로젝트 생성/수정/삭제 API
- [ ] 파트너별 프로젝트 조회 API

#### 4.2 프론트엔드 연동
- [ ] 수행 목록 탭 API 연동
- [ ] 프로젝트 관리 UI

### Phase 5: 제안 시스템 (2주)

#### 5.1 제안 API
- [ ] 제안 제출 API
- [ ] 제안 목록 조회 API
- [ ] 제안 상태 관리 API
- [ ] 프로세스 단계 관리 API

#### 5.2 제안 검토 시스템
- [ ] 제안 검토 UI (관리자)
- [ ] 프로세스 단계 변경 기능
- [ ] 제안 승인 시 파트너 자동 생성 (옵션)

#### 5.3 프론트엔드 연동
- [ ] 제안 제출 폼 API 연동
- [ ] 제안 상태 표시
- [ ] 제안 목록 페이지

### Phase 6: 뉴스/동향 관리 (1주)

#### 6.1 뉴스 API
- [ ] 뉴스 목록 조회 API
- [ ] 뉴스 관리 API (CRUD)
- [ ] 컨퍼런스 정보 관리

#### 6.2 프론트엔드 연동
- [ ] 시장 동향 섹션 API 연동
- [ ] 컨퍼런스 동향 섹션 API 연동
- [ ] 뉴스 관리 페이지 (관리자)

### Phase 7: 검색 및 필터링 고도화 (1주)

#### 7.1 검색 기능
- [ ] 전체 텍스트 검색 구현 (PostgreSQL Full-Text Search)
- [ ] 검색 API 구현
- [ ] 검색 결과 정렬 및 필터링

#### 7.2 고급 필터링
- [ ] 다중 조건 필터링
- [ ] 점수 범위 필터링
- [ ] 날짜 범위 필터링

#### 7.3 프론트엔드 연동
- [ ] 검색 UI 구현
- [ ] 고급 필터 UI 구현

### Phase 8: 성능 최적화 (1주)

#### 8.1 캐싱 전략
- [ ] Redis 설정
- [ ] 자주 조회되는 데이터 캐싱
- [ ] 캐시 무효화 전략

#### 8.2 데이터베이스 최적화
- [ ] 인덱스 최적화
- [ ] 쿼리 최적화
- [ ] N+1 문제 해결

#### 8.3 프론트엔드 최적화
- [ ] 이미지 최적화
- [ ] 코드 스플리팅
- [ ] Lazy Loading

### Phase 9: 보안 강화 (1주)

#### 9.1 보안 검토
- [ ] 입력 데이터 검증 강화
- [ ] SQL Injection 방지 검증
- [ ] XSS 방지 검증
- [ ] CSRF 보호 구현

#### 9.2 감사 로그
- [ ] 감사 로그 시스템 구현
- [ ] 중요 작업 로깅
- [ ] 로그 조회 API

### Phase 10: 테스트 및 문서화 (2주)

#### 10.1 테스트
- [ ] 단위 테스트 작성
- [ ] 통합 테스트 작성
- [ ] E2E 테스트 작성
- [ ] 성능 테스트

#### 10.2 문서화
- [ ] API 문서 작성 (Swagger/OpenAPI)
- [ ] 개발자 가이드 작성
- [ ] 배포 가이드 작성

### Phase 11: 배포 및 모니터링 (1주)

#### 11.1 배포 준비
- [ ] 프로덕션 환경 설정
- [ ] 환경 변수 관리
- [ ] 데이터베이스 백업 전략

#### 11.2 모니터링
- [ ] 로깅 시스템 구축
- [ ] 에러 추적 (Sentry 등)
- [ ] 성능 모니터링

---

## 기술 스택 선택

### 백엔드 프레임워크 옵션

#### 옵션 1: Next.js API Routes (권장)
**장점:**
- 프론트엔드와 같은 프로젝트에서 관리
- 배포 간편
- 서버리스 함수로 확장 가능

**단점:**
- 복잡한 비즈니스 로직 처리 시 제약
- 대규모 트래픽 처리 시 한계

**사용 시나리오:**
- 중소규모 프로젝트
- 빠른 개발 및 배포 필요
- 서버리스 아키텍처 선호

#### 옵션 2: Express.js + TypeScript
**장점:**
- 유연한 구조
- 풍부한 미들웨어 생태계
- 대규모 프로젝트에 적합

**단점:**
- 별도 서버 관리 필요
- 배포 복잡도 증가

**사용 시나리오:**
- 대규모 프로젝트
- 복잡한 비즈니스 로직
- 마이크로서비스 아키텍처

#### 옵션 3: NestJS
**장점:**
- Angular 스타일의 구조화된 아키텍처
- 의존성 주입
- 모듈화된 구조

**단점:**
- 학습 곡선
- 초기 설정 복잡

### ORM 선택

#### 옵션 1: Prisma (권장)
**장점:**
- 타입 안정성
- 직관적인 쿼리 API
- 마이그레이션 관리 편리
- Next.js와 통합 우수

**사용 예시:**
```typescript
// Prisma Client
const partners = await prisma.partner.findMany({
  where: {
    technologies: {
      some: {
        name: 'LLM'
      }
    }
  },
  include: {
    technologies: true,
    keywords: true
  }
});
```

#### 옵션 2: TypeORM
**장점:**
- 데코레이터 기반 모델 정의
- Active Record 패턴 지원
- 복잡한 쿼리 작성 용이

**단점:**
- 타입 안정성 상대적으로 낮음

#### 옵션 3: Drizzle ORM
**장점:**
- 가벼움
- SQL-like 쿼리
- 타입 안정성

### 데이터베이스

#### PostgreSQL (권장)
- 관계형 데이터베이스
- JSONB 지원
- Full-Text Search 지원
- 확장성 우수

#### Redis
- 캐싱
- 세션 저장
- 실시간 데이터 처리

### 인증 라이브러리

#### NextAuth.js (권장)
- Next.js와 통합 우수
- 다양한 인증 제공자 지원
- 세션 관리 자동화

#### JWT 직접 구현
- 더 세밀한 제어 가능
- 커스터마이징 용이

### 추천 기술 스택 (최종)

```
Backend Framework: Next.js API Routes
ORM: Prisma
Database: PostgreSQL
Cache: Redis
Authentication: NextAuth.js + JWT
Validation: Zod
API Documentation: Swagger/OpenAPI
Testing: Jest + React Testing Library
```

---

## 보안 고려사항

### 1. 인증 보안

- **비밀번호 정책**
  - 최소 8자 이상
  - 대소문자, 숫자, 특수문자 조합
  - 정기적 비밀번호 변경 권장

- **토큰 관리**
  - Access Token: 짧은 수명 (1시간)
  - Refresh Token: HTTP-only Cookie
  - 토큰 무효화 메커니즘

### 2. 데이터 보안

- **입력 검증**
  - 모든 사용자 입력 검증
  - SQL Injection 방지
  - XSS 방지

- **데이터 암호화**
  - 전송 중: HTTPS
  - 저장 시: 민감 정보 암호화

### 3. 접근 제어

- **권한 검증**
  - 모든 API 엔드포인트 권한 검증
  - 리소스 소유권 확인

- **Rate Limiting**
  - API 요청 제한
  - DDoS 방지

### 4. 감사 및 로깅

- **감사 로그**
  - 모든 중요 작업 로깅
  - 사용자 활동 추적

- **에러 처리**
  - 민감한 정보 노출 방지
  - 에러 로깅 및 모니터링

---

## 성능 최적화

### 1. 데이터베이스 최적화

- **인덱스 전략**
  - 자주 조회되는 컬럼 인덱싱
  - 복합 인덱스 활용
  - 인덱스 모니터링 및 튜닝

- **쿼리 최적화**
  - N+1 문제 해결 (Eager Loading)
  - 불필요한 데이터 조회 최소화
  - 쿼리 실행 계획 분석

### 2. 캐싱 전략

- **Redis 캐싱**
  - 파트너 목록 캐싱 (TTL: 5분)
  - 점수 데이터 캐싱 (TTL: 10분)
  - 인기 키워드 캐싱 (TTL: 1시간)

- **캐시 무효화**
  - 데이터 변경 시 관련 캐시 무효화
  - 태그 기반 캐시 무효화

### 3. API 최적화

- **페이징**
  - 모든 목록 API 페이징 구현
  - 커서 기반 페이징 고려

- **필드 선택**
  - GraphQL 또는 필드 선택 파라미터
  - 필요한 필드만 조회

### 4. 프론트엔드 최적화

- **데이터 페칭**
  - React Query / SWR 활용
  - 자동 재검증 설정
  - 낙관적 업데이트

- **코드 스플리팅**
  - 라우트 기반 코드 스플리팅
  - 동적 임포트 활용

---

## 배포 전략

### 1. 환경 구성

#### Development
- 로컬 개발 환경
- SQLite 또는 로컬 PostgreSQL
- Hot Reload 활성화

#### Staging
- 프로덕션과 유사한 환경
- 실제 데이터베이스 사용
- 테스트 데이터

#### Production
- 프로덕션 데이터베이스
- CDN 활용
- 모니터링 활성화

### 2. 배포 플랫폼 옵션

#### Vercel (권장)
- Next.js 최적화
- 자동 배포
- 서버리스 함수

#### AWS
- EC2 + RDS
- 더 많은 제어권
- 복잡한 설정

#### Docker
- 컨테이너화
- 다양한 환경 지원
- 확장성

### 3. CI/CD 파이프라인

```
1. 코드 푸시 → GitHub
2. 자동 테스트 실행
3. 빌드 및 배포
4. 스모크 테스트
5. 프로덕션 배포
```

### 4. 데이터베이스 마이그레이션 배포

- 마이그레이션 자동 실행
- 롤백 전략
- 데이터 백업

---

## 모니터링 및 로깅

### 1. 애플리케이션 모니터링

- **에러 추적**: Sentry
- **성능 모니터링**: Vercel Analytics / New Relic
- **로그 집계**: Logtail / Datadog

### 2. 데이터베이스 모니터링

- 쿼리 성능 모니터링
- 연결 풀 모니터링
- 디스크 사용량 모니터링

### 3. 알림 시스템

- 에러 발생 시 알림
- 성능 저하 시 알림
- 데이터베이스 이슈 알림

---

## 마이그레이션 체크리스트

### 데이터 마이그레이션

- [ ] 기존 샘플 데이터를 DB 형식으로 변환
- [ ] 데이터 검증 스크립트 작성
- [ ] 데이터 마이그레이션 실행
- [ ] 데이터 무결성 검증

### 코드 마이그레이션

- [ ] API 클라이언트 설정
- [ ] 모든 하드코딩된 데이터 제거
- [ ] API 호출로 대체
- [ ] 에러 처리 추가
- [ ] 로딩 상태 관리

### 테스트

- [ ] 단위 테스트 작성
- [ ] 통합 테스트 작성
- [ ] E2E 테스트 작성
- [ ] 성능 테스트

---

## 예상 일정

| Phase | 기간 | 누적 기간 |
|-------|------|----------|
| Phase 1: 기반 구축 | 2주 | 2주 |
| Phase 2: 파트너 데이터 연동 | 3주 | 5주 |
| Phase 3: 점수 평가 시스템 | 2주 | 7주 |
| Phase 4: 프로젝트 관리 | 1주 | 8주 |
| Phase 5: 제안 시스템 | 2주 | 10주 |
| Phase 6: 뉴스/동향 관리 | 1주 | 11주 |
| Phase 7: 검색 및 필터링 | 1주 | 12주 |
| Phase 8: 성능 최적화 | 1주 | 13주 |
| Phase 9: 보안 강화 | 1주 | 14주 |
| Phase 10: 테스트 및 문서화 | 2주 | 16주 |
| Phase 11: 배포 및 모니터링 | 1주 | 17주 |

**총 예상 기간: 약 17주 (4-5개월)**

---

## 리스크 및 대응 방안

### 기술적 리스크

1. **데이터 마이그레이션 실패**
   - 대응: 단계적 마이그레이션, 롤백 계획

2. **성능 이슈**
   - 대응: 조기 성능 테스트, 캐싱 전략

3. **보안 취약점**
   - 대응: 정기적 보안 검토, 보안 테스트

### 일정 리스크

1. **일정 지연**
   - 대응: 버퍼 시간 확보, 우선순위 조정

2. **요구사항 변경**
   - 대응: 유연한 아키텍처, 점진적 개발

---

## 다음 단계

1. **기술 스택 최종 결정**
   - 팀 회의를 통한 기술 스택 확정

2. **개발 환경 설정**
   - 로컬 개발 환경 구축
   - 데이터베이스 설정

3. **Phase 1 시작**
   - 데이터베이스 스키마 설계
   - ORM 설정

---

## 참고 자료

- [Prisma Documentation](https://www.prisma.io/docs)
- [Next.js API Routes](https://nextjs.org/docs/api-routes/introduction)
- [PostgreSQL Documentation](https://www.postgresql.org/docs/)
- [JWT Best Practices](https://datatracker.ietf.org/doc/html/rfc8725)

---

**문서 작성일**: 2026-01-XX  
**작성자**: Development Team  
**버전**: 1.0
